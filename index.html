<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motorcycle Navigator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .message-box {
            display: none;
        }
        .message-box.show {
            display: block;
        }
        #map {
            height: 400px; /* Set a specific height for the map */
            width: 100%;
            border-radius: 0.75rem;
        }
        .task-done {
            text-decoration: line-through;
            color: #9ca3af;
        }
        .custom-checkbox {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            height: 20px;
            width: 20px;
            background-color: #f3f4f6;
            border: 2px solid #d1d5db;
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            top: 2px;
        }
        .custom-checkbox:checked {
            background-color: #10b981;
            border-color: #10b981;
        }
        .custom-checkbox:checked::after {
            content: '';
            position: absolute;
            left: 5px;
            top: 1px;
            width: 5px;
            height: 10px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }
        #roadCurveCanvas {
            border-radius: 9999px; /* Make it a circle */
            background-color: #374151; /* Dark background */
            width: 150px; /* Square container for the circle */
            height: 150px;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <!-- Main Container -->
    <div class="bg-white p-8 rounded-xl shadow-lg w-full max-w-2xl mx-auto text-gray-800">
        <!-- Title -->
        <h1 class="text-3xl font-bold mb-6 text-center text-gray-900">Motorcycle Navigator</h1>
        
        <!-- Google Maps API Section -->
        <div class="mb-6">
            <h2 class="text-2xl font-semibold mb-4 text-gray-900">Route Planning</h2>
            <div id="map" class="mb-4"></div>
            <div class="space-y-4">
                <div class="text-gray-500 text-sm italic text-center">Your current location will be used as the origin.</div>
                <div>
                    <label for="destinationInput" class="block text-sm font-medium text-gray-700 mb-1">Destination</label>
                    <input type="text" id="destinationInput" placeholder="Enter destination (e.g., 'Los Angeles')" class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <button id="calculateRouteButton" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-3 px-6 rounded-lg transition-colors duration-300 shadow-md">
                    Calculate Route
                </button>
            </div>
        </div>
        
        <!-- Separator -->
        <hr class="my-6 border-gray-300">

        <!-- BLE Status & Connect Button -->
        <div class="flex flex-col items-center justify-center mb-6">
            <button id="connectButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-3 px-6 rounded-lg transition-colors duration-300 shadow-md">
                Connect to Device
            </button>
            <span id="status" class="mt-4 text-sm text-gray-500 font-medium">Disconnected</span>
        </div>
        
        <!-- Navigation Data Display -->
        <div id="dataDisplay" class="space-y-4 hidden">
            <h2 class="text-2xl font-semibold mb-4 text-gray-900 text-center">Navigation Panel</h2>

            <!-- Road Curve Visualization Canvas -->
            <div class="bg-gray-100 p-4 rounded-lg flex flex-col items-center justify-center">
                <p class="text-xs font-semibold uppercase text-gray-500 mb-2">Upcoming Road Curve</p>
                <canvas id="roadCurveCanvas" width="200" height="200"></canvas>
            </div>

            <!-- Next Turn Instruction -->
            <div class="bg-blue-50 p-4 rounded-lg">
                <p class="text-xs font-semibold uppercase text-gray-500 mb-1">Next Turn</p>
                <p id="nextTurnInstruction" class="text-xl font-bold">N/A</p>
            </div>
            
            <!-- Road Information -->
            <div class="bg-orange-50 p-4 rounded-lg">
                <p class="text-xs font-semibold uppercase text-gray-500 mb-1">Road Information</p>
                <p id="roadCurveInfo" class="text-xl font-bold">N/A</p>
            </div>
            
            <!-- Distance to Turn -->
            <div class="bg-green-50 p-4 rounded-lg">
                <p class="text-xs font-semibold uppercase text-gray-500 mb-1">Distance to Turn</p>
                <p id="distanceToTurn" class="text-xl font-bold">N/A</p>
            </div>
            
            <!-- Turn Direction -->
            <div class="bg-yellow-50 p-4 rounded-lg">
                <p class="text-xs font-semibold uppercase text-gray-500 mb-1">Turn Direction</p>
                <p id="turnDirection" class="text-xl font-bold">N/A</p>
            </div>
            
            <!-- ETA -->
            <div class="bg-indigo-50 p-4 rounded-lg">
                <p class="text-xs font-semibold uppercase text-gray-500 mb-1">ETA</p>
                <p id="eta" class="text-xl font-bold">N/A</p>
            </div>
        </div>
        
        <!-- Message Box -->
        <div id="messageBox" class="message-box mt-6 bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-md">
            <p id="messageText" class="font-medium"></p>
        </div>
    </div>
    
    <script>
        // UUIDs for the BLE Service and Characteristics (simulated for demonstration)
        const SERVICE_UUID = "6e400001-b5a3-f393-e0a9-e50e24dcca9e";

        // UI Element References
        const connectButton = document.getElementById('connectButton');
        const calculateRouteButton = document.getElementById('calculateRouteButton');
        const destinationInput = document.getElementById('destinationInput');
        const statusSpan = document.getElementById('status');
        const dataDisplayDiv = document.getElementById('dataDisplay');
        const nextTurnInstructionEl = document.getElementById('nextTurnInstruction');
        const distanceToTurnEl = document.getElementById('distanceToTurn');
        const turnDirectionEl = document.getElementById('turnDirection');
        const etaEl = document.getElementById('eta');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const roadCurveInfoEl = document.getElementById('roadCurveInfo');

        // New canvas-related references
        const roadCurveCanvas = document.getElementById('roadCurveCanvas');
        const ctx = roadCurveCanvas.getContext('2d');
        const canvasWidth = roadCurveCanvas.width;
        const canvasHeight = roadCurveCanvas.height;

        let bleDevice;
        let map, directionsService, directionsRenderer;
        let userMarker;
        let routePath = null;
        let currentStepIndex = 0;
        let navigationSteps = [];
        let geoWatchID = null;
        let lastPosition = null;
        let lastTimestamp = null;
        let routeTransferred = false; // Flag to simulate route sync

        // Function to display a message in the message box
        function displayMessage(message, isError = false) {
            messageText.textContent = message;
            if (isError) {
                messageBox.classList.remove('bg-green-100', 'border-green-500', 'text-green-700');
                messageBox.classList.add('bg-red-100', 'border-red-500', 'text-red-700');
            } else {
                messageBox.classList.remove('bg-red-100', 'border-red-500', 'text-green-700');
                messageBox.classList.add('bg-green-100', 'border-green-500', 'text-green-700');
            }
            messageBox.classList.add('show');
            setTimeout(() => {
                messageBox.classList.remove('show');
            }, 5000);
        }

        // --- NEW: Simulate BLE connection and data transfer ---
        function simulateBLEConnection() {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    const success = Math.random() > 0.1; // 90% chance of success
                    if (success) {
                        statusSpan.textContent = "Connected!";
                        displayMessage("Successfully connected to the device!");
                        resolve();
                    } else {
                        statusSpan.textContent = "Disconnected";
                        displayMessage("Connection failed. Please try again.", true);
                        reject(new Error("Simulated BLE connection failed."));
                    }
                }, 1500); // Simulate connection delay
            });
        }

        async function connect() {
            try {
                dataDisplayDiv.classList.add('hidden');
                statusSpan.textContent = "Scanning...";
                connectButton.disabled = true;

                // Simulate device connection
                await simulateBLEConnection();

            } catch (error) {
                console.error('BLE connection error:', error);
                statusSpan.textContent = "Disconnected";
                connectButton.disabled = false;
                dataDisplayDiv.classList.add('hidden');
            }
        }
        
        // Function to update the navigation panel in real-time (on the device)
        function updateNavigation(userLocation, userSpeed_mps) {
            if (!routePath || navigationSteps.length === 0) {
                roadCurveInfoEl.textContent = "N/A";
                return;
            }

            let closestDistance = Infinity;
            let closestPointIndex = -1;

            // Find the closest point on the entire route polyline
            for (let i = 0; i < routePath.length; i++) {
                const point = routePath[i];
                const distance = google.maps.geometry.spherical.computeDistanceBetween(userLocation, point);
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestPointIndex = i;
                }
            }
            
            let currentStepFound = false;
            for (let i = currentStepIndex; i < navigationSteps.length; i++) {
                const step = navigationSteps[i];
                const stepStart = new google.maps.LatLng(step.start_location.lat(), step.start_location.lng());
                const distanceToStepStart = google.maps.geometry.spherical.computeDistanceBetween(userLocation, stepStart);
                
                if (distanceToStepStart < closestDistance + 50) {
                    currentStepIndex = i;
                    currentStepFound = true;
                    break;
                }
            }

            if (currentStepIndex >= navigationSteps.length) {
                nextTurnInstructionEl.textContent = "You have arrived!";
                distanceToTurnEl.textContent = "0 m";
                turnDirectionEl.textContent = "N/A";
                etaEl.textContent = "N/A";
                roadCurveInfoEl.textContent = "N/A";
                drawRoadCurveVisualization([]);
                return;
            }

            const currentStep = navigationSteps[currentStepIndex];
            const remainingDistance = google.maps.geometry.spherical.computeDistanceBetween(userLocation, new google.maps.LatLng(currentStep.end_location.lat(), currentStep.end_location.lng()));
            
            const speed_mps = (userSpeed_mps > 0) ? userSpeed_mps : 2.778;
            const remainingTime_s = remainingDistance / speed_mps;
            const remainingTime_min = Math.ceil(remainingTime_s / 60);

            nextTurnInstructionEl.textContent = currentStep.instructions ? currentStep.instructions.replace(/<(?:.|\n)*?>/gm, '') : 'N/A';
            distanceToTurnEl.textContent = `${(remainingDistance).toFixed(0)} m`;
            
            const maneuver = currentStep.maneuver;
            
            turnDirectionEl.textContent = maneuver ? maneuver.replace(/_/g, ' ') : "Straight";
            
            etaEl.textContent = `${remainingTime_min} min`;

            let nextKmPoints = [];
            let distanceTraversed = 0;
            const viewDistance = 500;

            if (closestPointIndex !== -1) {
                for (let i = closestPointIndex; i < routePath.length; i++) {
                    const point = routePath[i];
                    if (i > 0) {
                        distanceTraversed += google.maps.geometry.spherical.computeDistanceBetween(routePath[i - 1], point);
                    }
                    if (distanceTraversed > viewDistance) {
                        break;
                    }
                    nextKmPoints.push(point);
                }
            }

            drawRoadCurveVisualization(nextKmPoints, userLocation);

            if (nextKmPoints.length > 5) {
                roadCurveInfoEl.textContent = "Upcoming Curves Ahead!";
            } else {
                roadCurveInfoEl.textContent = "Straight Road Ahead.";
            }
        }

        // Function to draw the road curve on the canvas
        function drawRoadCurveVisualization(points, userLocation) {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            if (points.length === 0) return;

            const closestPoint = points.reduce((closest, current) => {
                const currentDist = google.maps.geometry.spherical.computeDistanceBetween(userLocation, current);
                const closestDist = google.maps.geometry.spherical.computeDistanceBetween(userLocation, closest);
                return (currentDist < closestDist) ? current : closest;
            });

            let rotationAngle = 0;
            if (points.length > 1) {
                const nextPoint = points[1];
                const deltaLat = nextPoint.lat() - userLocation.lat();
                const deltaLng = nextPoint.lng() - userLocation.lng();
                rotationAngle = Math.atan2(deltaLng, deltaLat);
            }

            ctx.save();
            ctx.translate(canvasWidth / 2, canvasHeight / 2);
            ctx.rotate(-rotationAngle);
            
            let minLat = Infinity, maxLat = -Infinity, minLng = Infinity, maxLng = -Infinity;
            points.forEach(p => {
                minLat = Math.min(minLat, p.lat());
                maxLat = Math.max(maxLat, p.lat());
                minLng = Math.min(minLng, p.lng());
                maxLng = Math.max(maxLng, p.lng());
            });

            const latSpan = maxLat - minLat;
            const lngSpan = maxLng - minLng;
            const scaleFactor = 150000;

            const mapPointToCanvas = (point) => {
                const x = (point.lng() - userLocation.lng()) * scaleFactor;
                const y = (point.lat() - userLocation.lat()) * scaleFactor;
                return { x, y };
            };

            ctx.beginPath();
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            const firstPoint = mapPointToCanvas(points[0]);
            ctx.moveTo(firstPoint.x, firstPoint.y);
            points.forEach(point => {
                const { x, y } = mapPointToCanvas(point);
                ctx.lineTo(x, y);
            });
            ctx.stroke();

            ctx.restore();
        }

        // Initialize and add the map
        function initMap() {
            directionsService = new google.maps.DirectionsService();
            directionsRenderer = new google.maps.DirectionsRenderer();
            
            const defaultLocation = { lat: 34.0522, lng: -118.2437 }; // Los Angeles
            map = new google.maps.Map(document.getElementById("map"), {
                center: defaultLocation,
                zoom: 12,
            });
            directionsRenderer.setMap(map);
        }

        // Helper function to get the current location as a Promise
        function getCurrentPosition() {
            return new Promise((resolve, reject) => {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(resolve, reject, {
                        enableHighAccuracy: true,
                        maximumAge: 0,
                        timeout: 5000
                    });
                } else {
                    reject(new Error("Geolocation is not supported by your browser."));
                }
            });
        }

        async function calculateAndDisplayRoute() {
            const destination = destinationInput.value;
            const originalButtonText = calculateRouteButton.textContent;
            calculateRouteButton.textContent = "Calculating...";
            calculateRouteButton.disabled = true;

            if (!destination) {
                displayMessage("Please enter a destination.", true);
                calculateRouteButton.textContent = originalButtonText;
                calculateRouteButton.disabled = false;
                return;
            }

            try {
                const position = await getCurrentPosition();
                const userLocation = { lat: position.coords.latitude, lng: position.coords.longitude };
                
                const response = await directionsService.route({
                    origin: userLocation,
                    destination: destination,
                    travelMode: google.maps.TravelMode.DRIVING,
                });

                directionsRenderer.setDirections(response);
                
                const route = response.routes[0];
                if (route && route.legs && route.legs.length > 0) {
                    const leg = route.legs[0];
                    routePath = leg.steps.flatMap(step => step.path);
                    navigationSteps = leg.steps;
                    currentStepIndex = 0;
                    routeTransferred = true; // Route is now "synced" to the device
                    
                    displayMessage("Route successfully calculated and synced to device!");
                    dataDisplayDiv.classList.remove('hidden');

                    // Start live tracking now that a route is calculated
                    trackUserLocation();
                }

            } catch (error) {
                console.error('Error calculating route:', error);
                displayMessage(`Error: ${error.message}. Please try again.`, true);
            } finally {
                calculateRouteButton.textContent = originalButtonText;
                calculateRouteButton.disabled = false;
            }
        }
        
        // Function to track the user's live location and update the map
        function trackUserLocation() {
            if (geoWatchID !== null) {
                return;
            }

            geoWatchID = navigator.geolocation.watchPosition(
                (position) => {
                    const userLocation = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);
                    
                    let userSpeed_mps = 0;
                    if (lastPosition && lastTimestamp) {
                        const distance = google.maps.geometry.spherical.computeDistanceBetween(lastPosition, userLocation);
                        const timeElapsed = (position.timestamp - lastTimestamp) / 1000;
                        userSpeed_mps = distance / timeElapsed;
                    } else if (position.coords.speed !== null) {
                        userSpeed_mps = position.coords.speed;
                    }
                    lastPosition = userLocation;
                    lastTimestamp = position.timestamp;

                    if (!userMarker) {
                        userMarker = new google.maps.Marker({
                            position: userLocation,
                            map: map,
                            title: "Your Location",
                            icon: {
                                path: google.maps.SymbolPath.CIRCLE,
                                scale: 10,
                                fillColor: '#4285F4',
                                fillOpacity: 1,
                                strokeWeight: 2,
                                strokeColor: '#FFFFFF',
                            },
                        });
                    } else {
                        userMarker.setPosition(userLocation);
                    }

                    if (navigationSteps.length > 0) {
                      map.setCenter(userLocation);
                    }
                    
                    // Update navigation only if a route is synced (simulated device logic)
                    if (routeTransferred) {
                        updateNavigation(userLocation, userSpeed_mps);
                    }

                    console.log(`Live location update: Lat ${userLocation.lat()}, Lng ${userLocation.lng()}`);
                },
                (error) => {
                    console.error('Geolocation error:', error);
                    displayMessage('Could not get your location. Please enable location services.', true);
                },
                {
                    enableHighAccuracy: true,
                    maximumAge: 0,
                    timeout: 5000
                }
            );
        }

        // Add event listeners to the buttons
        connectButton.addEventListener('click', connect);
        calculateRouteButton.addEventListener('click', calculateAndDisplayRoute);

    </script>
    <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB-NXVll1SQAbzDhRRbTmVzs6t1vr7Ftxs=&callback=initMap&libraries=geometry&signature=6wQ_lnbB92J3tf3KVD7BD9DNkMw="></script>
</body>
</html>
